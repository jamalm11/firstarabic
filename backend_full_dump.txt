

Voici la liste exhaustive des fichiers typiquement utilisÃ©s dans ton projet backend Node.js avec Supabase, en te basant sur tout ce que tu mâ€™as partagÃ© jusquâ€™ici (structure validÃ©e, routes modularisÃ©es, authentification, validation, Supabase, cours, rÃ©servations, paiements, notifications, etc.).
ğŸ“ Structure complÃ¨te du dossier backend/

backend/
â”œâ”€â”€ index.js                        # Point dâ€™entrÃ©e principal du serveur Express
â”œâ”€â”€ supabaseClient.js              # Client Supabase cÃ´tÃ© utilisateur (avec token)
â”œâ”€â”€ supabaseAdminClient.js         # Client Supabase avec service_role (admin)
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ authenticateToken.js       # Middleware pour valider le JWT Supabase
â”œâ”€â”€ validators/
â”‚   â”œâ”€â”€ coursValidator.js          # SchÃ©ma Joi pour valider un cours
â”‚   â”œâ”€â”€ eleveValidator.js          # SchÃ©ma Joi pour Ã©lÃ¨ve
â”‚   â”œâ”€â”€ profValidator.js           # SchÃ©ma Joi pour professeur
â”‚   â””â”€â”€ ...                        # Autres validateurs (abonnement, disponibilitÃ©â€¦)
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ abonnementsRoutes.js       # Routes Stripe pour abonnements + paiement
â”‚   â”œâ”€â”€ coursRoutes.js             # Routes pour crÃ©er/lister les cours
â”‚   â”œâ”€â”€ elevesRoutes.js            # Routes pour gÃ©rer les Ã©lÃ¨ves
â”‚   â”œâ”€â”€ profsRoutes.js             # Routes pour gÃ©rer les profs
â”‚   â”œâ”€â”€ disponibilitesRoutes.js    # Routes CRUD des disponibilitÃ©s des profs
â”‚   â”œâ”€â”€ planningRoutes.js          # Routes pour lâ€™agenda/planning
â”‚   â”œâ”€â”€ reservationsRoutes.js      # Routes pour les rÃ©servations
â”‚   â”œâ”€â”€ notificationsRoutes.js     # Routes pour l'envoi de mails, alertes
â”‚   â””â”€â”€ stripeWebhook.js           # Webhook Stripe (/stripe/webhook)
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ email.js                   # Fonction `sendEmail` via Nodemailer
â”‚   â””â”€â”€ ...                        # Autres helpers Ã©ventuels (Jitsi, logsâ€¦)
â”œâ”€â”€ .env                           # Fichier dâ€™environnement (SUPABASE_URL, KEYâ€¦)
â”œâ”€â”€ package.json                   # DÃ©pendances et scripts npm
â””â”€â”€ README.md                      # (Optionnel) Documentation technique


ğŸ“Œ RÃ©sumÃ© des composants

ğŸ“¦ CatÃ©gorie
Fichiers principaux
EntrÃ©e serveur
index.js
Routes
Tous les *.js dans routes/
Middleware
authenticateToken.js
Validation Joi
coursValidator.js, eleveValidator.js, profValidator.js, etc.
Supabase clients
supabaseClient.js, supabaseAdminClient.js
Utilitaires
email.js, et potentiellement dâ€™autres Ã  ajouter dans utils/
Paiement
abonnementsRoutes.js, stripeWebhook.js
DonnÃ©es sensibles
.env (clÃ© Supabase, Stripe secret, etc.)





====== backend/index.js ======

// backend/index.js

const express = require('express');
const cors = require('cors');
require('dotenv').config();
const { createClient } = require('@supabase/supabase-js');
const rateLimit = require("express-rate-limit");
const authenticateToken = require('./middleware/authenticateToken');

const app = express();
const PORT = 3001;

// Middleware globaux
app.use(cors());
app.use(express.json());

// Supabase public client (lecture publique non protÃ©gÃ©e)
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;

const supabase = createClient(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: false,
    autoRefreshToken: false,
    detectSessionInUrl: false
  }
});

// ğŸ” Logger global
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
  next();
});

// ========== ROUTES ==========

app.use('/eleves', require('./routes/elevesRoutes'));
app.use('/profs', require('./routes/profRoutes'));
app.use('/cours', require('./routes/coursRoutes'));  // âœ… Route des cours bien positionnÃ©e
app.use('/disponibilites', require('./routes/disponibilitesRoutes'));
app.use('/reservations', require('./routes/reservationsRoutes'));
app.use('/notifications', require('./routes/notificationsRoutes'));
app.use('/abonnements', require('./routes/abonnementRoutes'));
app.use('/planning', require('./routes/planningRoutes'));
app.use('/creneaux', require('./routes/planningRoutes')); // âš ï¸ attention doublon possible
app.use('/check-email', require('./routes/checkEmailRoutes'));
app.use('/stripe', require('./routes/stripeRoutes'));
// app.use('/auth', require('./routes/authRoutes')); // si activÃ©e plus tard

// âœ… Route de test
app.get('/', (req, res) => {
  res.json({ status: "ğŸš€ API FirstArabic opÃ©rationnelle !" });
});

// Lancement serveur
app.listen(PORT, () => {
  console.log(`âœ… API en Ã©coute sur http://localhost:${PORT}`);
});


====== backend/supabaseClient.js ======


// backend/supabaseClient.js
require('dotenv').config();
const { createClient } = require('@supabase/supabase-js');

const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY);

module.exports = supabase;



====== backend/supabaseAdminClient.js ======

// backend/supabaseAdminClient.js
const { createClient } = require("@supabase/supabase-js");

const supabaseAdmin = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

module.exports = supabaseAdmin;


====== backend/middleware/authenticateToken.js ======

// backend/middleware/authenticateToken.js

const { createClient } = require("@supabase/supabase-js");
require("dotenv").config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;

const authenticateToken = async (req, res, next) => {
  console.log("ğŸ” [Middleware] authenticateToken appelÃ©");

  const rawAuthHeader = req.headers.authorization;
  console.log("ğŸ“¥ Header Authorization brut :", rawAuthHeader);

  const token = rawAuthHeader?.split(" ")[1];

  if (!token) {
    console.warn("ğŸš« Token manquant dans l'en-tÃªte Authorization");
    return res.status(401).json({ error: "Token manquant" });
  }

  console.log("ğŸ”‘ Token extrait :", token);

  try {
    const supabase = createClient(supabaseUrl, supabaseKey, {
      global: { headers: { Authorization: `Bearer ${token}` } },
      auth: { persistSession: false }
    });

    console.log("ğŸ”„ Appel Ã  supabase.auth.getUser()...");
    const { data, error } = await supabase.auth.getUser();
    const user = data?.user;

    if (error || !user) {
      console.warn("ğŸš« Token invalide ou utilisateur introuvable", error?.message || "");
      return res.status(401).json({ error: "Token invalide ou utilisateur non trouvÃ©" });
    }

    console.log(`âœ… Utilisateur authentifiÃ© : ${user.email} (ID: ${user.id})`);
    req.user = user;
    req.supabase = supabase;

    console.log("â¡ï¸ Passage au middleware suivant");
    next();
  } catch (err) {
    console.error("âŒ Erreur dans authenticateToken :", err.message);
    res.status(500).json({ error: "Erreur d'authentification", details: err.message });
  }
};

module.exports = authenticateToken;


====== backend/validators/coursValidator.js ======

// backend/validators/coursValidator.js
const Joi = require('joi');

const coursSchema = Joi.object({
  date: Joi.date().iso().required(),
  prof_id: Joi.string().uuid().required(),
  eleve_id: Joi.string().uuid().required(),
  jitsi_url: Joi.string().uri().optional(),
  statut: Joi.string().valid('prÃ©vu', 'annulÃ©', 'terminÃ©').optional(),
  created_by: Joi.string().uuid().optional(),
  created_at: Joi.date().optional()
});

module.exports = { coursSchema };


====== backend/validators/eleveValidator.js ======

const Joi = require('joi');

const eleveInputSchema = Joi.object({
  nom: Joi.string().min(2).max(100).required(),
  email: Joi.string().email().optional()
});

const eleveSchema = Joi.object({
  nom: Joi.string().required(),
  email: Joi.string().email().optional(),
  created_by: Joi.string().uuid().required()
});

module.exports = { eleveSchema, eleveInputSchema };


====== backend/validators/profValidator.js ======

const Joi = require('joi');

const profSchema = Joi.object({
  nom: Joi.string().required(),
  specialite: Joi.string().allow('').optional(),
  bio: Joi.string().allow('').optional()
});

module.exports = { profSchema };


====== backend/routes/abonnementsRoutes.js (NOT FOUND) ======



====== backend/routes/coursRoutes.js ======

// backend/routes/coursRoutes.js
const express = require("express");
const router = express.Router();
const { coursSchema } = require("../validators/coursValidator");
const { createClient } = require("@supabase/supabase-js");
const supabaseAdmin = require("../supabaseAdminClient");

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;

const initSupabase = (req) =>
  createClient(supabaseUrl, supabaseKey, {
    global: { headers: { Authorization: req.headers.authorization } },
  });

// ğŸ“¥ CrÃ©er un cours
router.post("/", async (req, res) => {
  console.log("\nğŸŸ¢ [API] POST /cours appelÃ©e");
  console.log("ğŸ“¥ DonnÃ©es reÃ§ues dans le body:", JSON.stringify(req.body, null, 2));

  const { error: validationError } = coursSchema.validate(req.body);
  if (validationError) {
    console.log("ğŸš« [Validation] Erreur Joi:", validationError.details[0].message);
    return res.status(400).json({
      error: "DonnÃ©es invalides",
      details: validationError.details[0].message,
    });
  }

  const supabase = initSupabase(req);
  const { date, prof_id, eleve_id } = req.body;

  try {
    console.log("ğŸ” Tentative rÃ©cupÃ©ration utilisateur courant...");
    const { data: userData, error: userError } = await supabase.auth.getUser();
    if (userError || !userData?.user) {
      console.log("ğŸš« [Auth] Erreur rÃ©cupÃ©ration utilisateur:", userError?.message);
      return res.status(401).json({ message: "Utilisateur non authentifiÃ©" });
    }

    const user_id = userData.user.id;
    console.log("âœ… [Auth] Utilisateur authentifiÃ© ID:", user_id);

    console.log(`ğŸ” VÃ©rification de l'Ã©lÃ¨ve ${eleve_id} appartenant Ã  l'utilisateur...`);
    const { data: eleve, error: eleveError } = await supabase
      .from("eleves")
      .select("*")
      .eq("id", eleve_id)
      .eq("created_by", user_id)
      .single();

    if (eleveError || !eleve) {
      console.log("ğŸš« [SÃ©curitÃ©] Ã‰lÃ¨ve introuvable ou non autorisÃ©:", eleveError?.message || "Aucun Ã©lÃ¨ve retournÃ©");
      return res.status(403).json({ message: "Ã‰lÃ¨ve non autorisÃ© ou inexistant" });
    }

    // ğŸ”— GÃ©nÃ©ration du lien Jitsi
    const jitsiRoom = `firstarabic-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
    const lien_jitsi = `https://meet.jit.si/${jitsiRoom}`;
    console.log("ğŸ”— Lien Jitsi gÃ©nÃ©rÃ© :", lien_jitsi);

    console.log("âœ… [SÃ©curitÃ©] Ã‰lÃ¨ve autorisÃ©. Passage Ã  l'insertion du cours...");
    console.log("ğŸ“¤ DonnÃ©es insÃ©rÃ©es:", { date, prof_id, eleve_id, lien_jitsi });

    const { error: insertError } = await supabase
      .from("cours")
      .insert([{ date, prof_id, eleve_id, jitsi_url: lien_jitsi }]);

    if (insertError) {
      console.log("âŒ [DB] Erreur insertion cours:", insertError.message);
      return res.status(500).json({ message: "Erreur crÃ©ation cours" });
    }

    console.log("âœ… [SuccÃ¨s] Cours insÃ©rÃ© avec succÃ¨s âœ…");
    return res.status(200).json({ message: "Cours rÃ©servÃ© avec succÃ¨s", lien_jitsi });
  } catch (err) {
    console.error("âŒ [Exception] Erreur inattendue dans POST /cours:", err);
    return res.status(500).json({ message: "Erreur serveur" });
  }
});

module.exports = router;


====== backend/routes/elevesRoutes.js ======

// routes/elevesRoutes.js
const express = require('express');
const router = express.Router();

const { eleveInputSchema } = require('../validators/eleveValidator');
const authenticateToken = require('../middleware/authenticateToken');
const supabaseAdmin = require('../supabaseAdminClient');
const { sendEmail } = require("../utils/email");


// ğŸ†• CrÃ©er un Ã©lÃ¨ve
router.post("/", authenticateToken, async (req, res) => {
  console.log("ğŸ¯ [POST /eleves] RequÃªte reÃ§ue");
  console.log("ğŸ“¦ Corps de la requÃªte:", req.body);

  const { error: validationError } = eleveInputSchema.validate({
    nom: req.body.nom,
    email: req.body.email,
  });

  if (validationError) {
    console.warn("âŒ DonnÃ©es invalides:", validationError.details[0].message);
    return res.status(400).json({ error: "DonnÃ©es invalides", details: validationError.details[0].message });
  }

  const { nom, email } = req.body;
  const userId = req.user?.id;
  console.log(`ğŸ” Utilisateur ID: ${userId} - CrÃ©ation d'Ã©lÃ¨ve avec nom: ${nom}, email: ${email}`);

  try {
    console.log("ğŸ“¥ Insertion dans la table 'eleves'...");
    const { data, error } = await supabaseAdmin
      .from("eleves")
      .insert([{ nom, email, created_by: userId }])
      .select();

    if (error) throw error;
    console.log("âœ… Ã‰lÃ¨ve crÃ©Ã© dans la BDD:", data[0]);

    console.log("âœ‰ï¸ Envoi de l'email de bienvenue...");
    await sendEmail(
      email,
      "Bienvenue sur FirstArabic ! ğŸŒŸ",
      `
        <h2>Bienvenue ${nom} !</h2>
        <p>Votre compte a Ã©tÃ© crÃ©Ã© avec succÃ¨s. Vous pouvez maintenant rÃ©server des cours sur notre plateforme.</p>
        <p><a href="https://firstarabic.com">AccÃ©der Ã  la plateforme</a></p>
      `
    );
    console.log("ğŸ“¨ Email envoyÃ© Ã :", email);

    res.json({ success: true, eleve: data[0] });
  } catch (e) {
    console.error("ğŸ’¥ Erreur crÃ©ation Ã©lÃ¨ve:", e.message);
    res.status(500).json({ error: "Erreur creation eleve", details: e.message });
  }
});


// ğŸ” Liste des Ã©lÃ¨ves du user connectÃ©
router.get('/', authenticateToken, async (req, res) => {
  const userId = req.user?.id;
  console.log(`ğŸ” [GET /eleves] RÃ©cupÃ©ration des Ã©lÃ¨ves pour user ID: ${userId}`);

  try {
    const { data, error } = await supabaseAdmin
      .from('eleves')
      .select('*')
      .eq('created_by', userId);

    if (error) throw error;
    console.log("ğŸ“‹ Ã‰lÃ¨ves rÃ©cupÃ©rÃ©s:", data);
    res.json({ success: true, eleves: data });
  } catch (e) {
    console.error("ğŸ’¥ Erreur rÃ©cupÃ©ration Ã©lÃ¨ves:", e.message);
    res.status(500).json({ error: "Erreur recuperation eleves", details: e.message });
  }
});


// ğŸ” DÃ©tail dâ€™un Ã©lÃ¨ve
router.get('/:id', authenticateToken, async (req, res) => {
  const userId = req.user?.id;
  const eleveId = req.params.id;
  console.log(`ğŸ” [GET /eleves/${eleveId}] RÃ©cupÃ©ration Ã©lÃ¨ve pour user ID: ${userId}`);

  try {
    const { data, error } = await supabaseAdmin
      .from('eleves')
      .select('*')
      .eq('id', eleveId)
      .eq('created_by', userId)
      .maybeSingle();

    if (error) throw error;
    console.log("ğŸ“„ Ã‰lÃ¨ve trouvÃ©:", data);
    res.json({ success: true, eleve: data });
  } catch (e) {
    console.error("ğŸ’¥ Erreur rÃ©cupÃ©ration Ã©lÃ¨ve:", e.message);
    res.status(404).json({ error: "eleve non trouve", details: e.message });
  }
});


// âœï¸ Modifier un Ã©lÃ¨ve
router.put('/:id', authenticateToken, async (req, res) => {
  const userId = req.user?.id;
  const eleveId = req.params.id;
  const { nom } = req.body;

  console.log(`âœï¸ [PUT /eleves/${eleveId}] Modification de l'Ã©lÃ¨ve pour user ID: ${userId}`);
  console.log("ğŸ“ Nouveau nom:", nom);

  if (!nom) {
    console.warn("âš ï¸ Nom manquant");
    return res.status(400).json({ error: "Nom requis" });
  }

  try {
    const { data, error } = await supabaseAdmin
      .from('eleves')
      .update({ nom })
      .eq('id', eleveId)
      .eq('created_by', userId)
      .select();

    if (error) throw error;
    console.log("âœ… Ã‰lÃ¨ve mis Ã  jour:", data[0]);
    res.json({ success: true, eleve: data[0] });
  } catch (e) {
    console.error("ğŸ’¥ Erreur mise Ã  jour Ã©lÃ¨ve:", e.message);
    res.status(500).json({ error: "Erreur mise a jour eleve", details: e.message });
  }
});


// ğŸ—‘ï¸ Supprimer un Ã©lÃ¨ve
router.delete('/:id', authenticateToken, async (req, res) => {
  const userId = req.user?.id;
  const eleveId = req.params.id;
  console.log(`ğŸ—‘ï¸ [DELETE /eleves/${eleveId}] Suppression de l'Ã©lÃ¨ve pour user ID: ${userId}`);

  try {
    const { error } = await supabaseAdmin
      .from('eleves')
      .delete()
      .eq('id', eleveId)
      .eq('created_by', userId);

    if (error) throw error;
    console.log("ğŸ§¹ Ã‰lÃ¨ve supprimÃ© avec succÃ¨s");
    res.json({ success: true, message: "eleve supprime" });
  } catch (e) {
    console.error("ğŸ’¥ Erreur suppression Ã©lÃ¨ve:", e.message);
    res.status(500).json({ error: "Erreur suppression eleve", details: e.message });
  }
});

module.exports = router;


====== backend/routes/profsRoutes.js (NOT FOUND) ======



====== backend/routes/disponibilitesRoutes.js ======

// backend/routes/disponibilitesRoutes.js
const express = require("express");
const router = express.Router();
const { disponibiliteSchema, updateDisponibiliteSchema } = require("../validators/disponibiliteValidator");
const authenticateToken = require("../middleware/authenticateToken");
const supabaseAdmin = require("../supabaseAdminClient");

// ğŸ”’ Middleware
router.use(authenticateToken);

// âœ… CrÃ©er une disponibilitÃ©
router.post("/", async (req, res) => {
  console.log("ğŸ†• [POST] /disponibilites - DonnÃ©es reÃ§ues:", req.body);

  const { error } = disponibiliteSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details[0].message });

  const { jour, heure_debut, heure_fin, prof_id } = req.body;

  try {
    const { data, error } = await supabaseAdmin
      .from("disponibilites")
      .insert([{ jour, heure_debut, heure_fin, prof_id }])
      .select();

    if (error) throw error;

    res.json({ success: true, disponibilite: data[0] });
  } catch (err) {
    console.error("âŒ Erreur crÃ©ation disponibilitÃ©:", err);
    res.status(500).json({ error: "Erreur crÃ©ation disponibilitÃ©", details: err.message });
  }
});

// âœ… RÃ©cupÃ©rer toutes les disponibilitÃ©s
router.get("/", async (req, res) => {
  try {
    const { data, error } = await req.supabase.from("disponibilites").select("*");
    if (error) throw error;
    res.json({ success: true, disponibilites: data });
  } catch (err) {
    console.error("âŒ Erreur rÃ©cupÃ©ration disponibilitÃ©s:", err);
    res.status(500).json({ error: "Erreur rÃ©cupÃ©ration disponibilitÃ©s", details: err.message });
  }
});

// âœ… RÃ©cupÃ©rer une disponibilitÃ© par ID
router.get("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { data, error } = await req.supabase
      .from("disponibilites")
      .select("*")
      .eq("id", id)
      .maybeSingle();

    if (error) throw error;
    res.json({ success: true, disponibilite: data });
  } catch (err) {
    console.error("âŒ Erreur rÃ©cupÃ©ration disponibilitÃ© par ID:", err);
    res.status(500).json({ error: "Erreur rÃ©cupÃ©ration disponibilitÃ©", details: err.message });
  }
});

// âœ… Mettre Ã  jour une disponibilitÃ© (PUT)
router.put("/:id", async (req, res) => {
  console.log("âœï¸ [PUT] /disponibilites/:id - DonnÃ©es reÃ§ues:", req.body);

  const { error } = disponibiliteSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details[0].message });

  try {
    const { id } = req.params;
    const { jour, heure_debut, heure_fin, prof_id } = req.body;

    const { data, error } = await req.supabase
      .from("disponibilites")
      .update({ jour, heure_debut, heure_fin, prof_id })
      .eq("id", id)
      .select();

    if (error) throw error;
    res.json({ success: true, disponibilite: data[0] });
  } catch (err) {
    console.error("âŒ Erreur mise Ã  jour disponibilitÃ©:", err);
    res.status(500).json({ error: "Erreur mise Ã  jour disponibilitÃ©", details: err.message });
  }
});

// âœ… Mettre Ã  jour partiellement une disponibilitÃ© (PATCH)
router.patch("/:id", async (req, res) => {
  console.log("âœï¸ [PATCH] /disponibilites/:id - DonnÃ©es reÃ§ues:", req.body);

  const { error } = updateDisponibiliteSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details[0].message });

  try {
    const { id } = req.params;
    const updateFields = req.body;

    const { data, error } = await req.supabase
      .from("disponibilites")
      .update(updateFields)
      .eq("id", id)
      .select();

    if (error) throw error;
    res.json({ success: true, disponibilite: data[0] });
  } catch (err) {
    console.error("âŒ Erreur patch disponibilitÃ©:", err);
    res.status(500).json({ error: "Erreur mise Ã  jour disponibilitÃ©", details: err.message });
  }
});

// âœ… Supprimer une disponibilitÃ©
router.delete("/:id", async (req, res) => {
  try {
    const { id } = req.params;

    const { error } = await req.supabase
      .from("disponibilites")
      .delete()
      .eq("id", id);

    if (error) throw error;
    res.json({ success: true, message: "DisponibilitÃ© supprimÃ©e" });
  } catch (err) {
    console.error("âŒ Erreur suppression disponibilitÃ©:", err);
    res.status(500).json({ error: "Erreur suppression disponibilitÃ©", details: err.message });
  }
});

module.exports = router;


====== backend/routes/planningRoutes.js ======

// backend/routes/planningRoutes.js
const express = require("express");
const authenticateToken = require("../middleware/authenticateToken");

const router = express.Router();

// ğŸ“… RÃ©cupÃ©rer tous les cours de l'utilisateur connectÃ©
router.get("/", authenticateToken, async (req, res) => {
  try {
    const statut = req.query.statut || null;

    const { data, error } = await req.supabase
      .from("cours")
      .select(`
        id, date, statut, jitsi_url,
        profs (nom),
        eleves (nom)
      `)
      .eq("created_by", req.user.id);

    if (error) throw error;

    const planning = data
      .filter(c => !statut || c.statut === statut)
      .map(c => ({
        id: c.id,
        date: c.date,
        statut: c.statut,
        lien: c.jitsi_url,
        prof: c.profs?.nom || null,
        eleve: c.eleves?.nom || null
      }));

    res.json({ success: true, planning });
  } catch (e) {
    res.status(500).json({ error: "Erreur rÃ©cupÃ©ration planning", details: e.message });
  }
});

// ğŸ“… RÃ©cupÃ©rer les crÃ©neaux rÃ©servÃ©s (cours confirmÃ©s)
router.get("/reserves", authenticateToken, async (req, res) => {
  try {
    const { prof_id } = req.query;
    if (!prof_id) return res.status(400).json({ error: "prof_id requis" });

    const { data, error } = await req.supabase
      .from("cours")
      .select("date")
      .eq("prof_id", prof_id)
      .eq("statut", "confirme");

    if (error) throw error;

    const dureeCoursMin = 30;
    const reserves = data.map(c => {
      const start = new Date(c.date);
      const end = new Date(start.getTime() + dureeCoursMin * 60000);
      return { start: start.toISOString(), end: end.toISOString() };
    });

    res.json({ success: true, reserves });
  } catch (e) {
    res.status(500).json({ error: "Erreur rÃ©cupÃ©ration crÃ©neaux rÃ©servÃ©s", details: e.message });
  }
});

// ğŸ“† RÃ©cupÃ©rer les crÃ©neaux disponibles pour un prof
router.get("/disponibles", authenticateToken, async (req, res) => {
  try {
    const { prof_id } = req.query;
    if (!prof_id) return res.status(400).json({ error: "prof_id requis" });

    const { data: disponibilites, error: dispoError } = await req.supabase
      .from("disponibilites")
      .select("jour, heure_debut, heure_fin")
      .eq("prof_id", prof_id);
    if (dispoError) throw dispoError;

    const joursMap = {
      lundi: 1, mardi: 2, mercredi: 3, jeudi: 4, vendredi: 5, samedi: 6, dimanche: 0
    };

    const dureeCoursMin = 30;
    const now = new Date();
    const prochainsCreneaux = [];

    for (const dispo of disponibilites) {
      const dayOffset = (7 + joursMap[dispo.jour.toLowerCase()] - now.getDay()) % 7;
      const dateCreneau = new Date(now);
      dateCreneau.setDate(now.getDate() + dayOffset);
      dateCreneau.setHours(0, 0, 0, 0);

      const [hStart, mStart] = dispo.heure_debut.split(":").map(Number);
      const [hEnd, mEnd] = dispo.heure_fin.split(":").map(Number);

      const start = new Date(dateCreneau);
      start.setHours(hStart, mStart, 0);

      const end = new Date(dateCreneau);
      end.setHours(hEnd, mEnd, 0);

      for (let t = new Date(start); t < end; t.setMinutes(t.getMinutes() + dureeCoursMin)) {
        const creneauStart = new Date(t);
        const creneauEnd = new Date(t.getTime() + dureeCoursMin * 60000);
        prochainsCreneaux.push({ start: creneauStart.toISOString(), end: creneauEnd.toISOString() });
      }
    }

    const { data: reserves, error: reserveError } = await req.supabase
      .from("cours")
      .select("date")
      .eq("prof_id", prof_id)
      .eq("statut", "confirme");
    if (reserveError) throw reserveError;

    const reservesSet = new Set(reserves.map(r => new Date(r.date).toISOString()));
    const disponibles = prochainsCreneaux.filter(c => !reservesSet.has(c.start));

    res.json({ success: true, disponibles });
  } catch (e) {
    res.status(500).json({ error: "Erreur rÃ©cupÃ©ration disponibilitÃ©s filtrÃ©es", details: e.message });
  }
});

module.exports = router;


====== backend/routes/reservationsRoutes.js ======

// backend/routes/reservationsRoutes.js
const express = require("express");
const router = express.Router();
const { createReservationSchema, updateReservationSchema } = require("../validators/reservationValidator");
const authenticateToken = require("../middleware/authenticateToken");
const supabaseAdmin = require("../supabaseAdminClient");

// ğŸ”’ Middleware
router.use(authenticateToken);

// âœ… CrÃ©er une rÃ©servation
router.post("/", async (req, res) => {
  console.log("ğŸ†• [POST] /reservations - DonnÃ©es reÃ§ues:", req.body);

  const { error } = createReservationSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details[0].message });

  try {
    const { prof_id, date, heure_debut, heure_fin, statut } = req.body;

    const { data, error } = await supabaseAdmin
      .from("reservations")
      .insert([{ prof_id, date, heure_debut, heure_fin, statut }])
      .select();

    if (error) throw error;

    res.json({ success: true, reservation: data[0] });
  } catch (err) {
    console.error("âŒ Erreur crÃ©ation rÃ©servation:", err);
    res.status(500).json({ error: "Erreur crÃ©ation rÃ©servation", details: err.message });
  }
});

// âœ… Lire toutes les rÃ©servations
router.get("/", async (req, res) => {
  try {
    const { data, error } = await req.supabase.from("reservations").select("*");
    if (error) throw error;
    res.json({ success: true, reservations: data });
  } catch (err) {
    console.error("âŒ Erreur rÃ©cupÃ©ration rÃ©servations:", err);
    res.status(500).json({ error: "Erreur rÃ©cupÃ©ration rÃ©servations", details: err.message });
  }
});

// âœ… Lire une rÃ©servation par ID
router.get("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { data, error } = await req.supabase
      .from("reservations")
      .select("*")
      .eq("id", id)
      .maybeSingle();

    if (error) throw error;
    res.json({ success: true, reservation: data });
  } catch (err) {
    console.error("âŒ Erreur rÃ©cupÃ©ration rÃ©servation:", err);
    res.status(500).json({ error: "Erreur rÃ©cupÃ©ration rÃ©servation", details: err.message });
  }
});

// âœ… Modifier une rÃ©servation
router.put("/:id", async (req, res) => {
  console.log("âœï¸ [PUT] /reservations/:id - DonnÃ©es reÃ§ues:", req.body);

  const { error } = updateReservationSchema.validate(req.body);
  if (error) return res.status(400).json({ error: error.details[0].message });

  try {
    const { id } = req.params;
    const { data, error } = await req.supabase
      .from("reservations")
      .update(req.body)
      .eq("id", id)
      .select();

    if (error) throw error;
    res.json({ success: true, reservation: data[0] });
  } catch (err) {
    console.error("âŒ Erreur mise Ã  jour rÃ©servation:", err);
    res.status(500).json({ error: "Erreur mise Ã  jour rÃ©servation", details: err.message });
  }
});

// âœ… Supprimer une rÃ©servation
router.delete("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { error } = await req.supabase.from("reservations").delete().eq("id", id);
    if (error) throw error;
    res.json({ success: true, message: "RÃ©servation supprimÃ©e" });
	  } catch (err) {
    console.error("âŒ Erreur suppression rÃ©servation:", err);
    res.status(500).json({ error: "Erreur suppression rÃ©servation", details: err.message });
  }
});

module.exports = router;



====== backend/routes/notificationsRoutes.js ======

// backend/routes/notificationsRoutes.js
const express = require('express');
const router = express.Router();
const { notificationSchema, updateNotificationSchema } = require('../validators/notificationValidator');
const authenticateToken = require('../middleware/authenticateToken');
const supabase = require('../supabaseClient');

// ğŸ“¥ CrÃ©er une notification
router.post('/', authenticateToken, async (req, res) => {
  const { error: validationError } = notificationSchema.validate(req.body);
  if (validationError) {
    return res.status(400).json({ error: "DonnÃ©es invalides", details: validationError.details[0].message });
  }

  const { message, lue, type } = req.body;
  const created_by = req.user.id;

  try {
    const { data, error } = await supabase
      .from('notifications')
      .insert([{ message, lue: lue || false, type: type || 'info', created_by }])
      .select()
      .maybeSingle();

    if (error) throw error;
    console.log("âœ… Notification crÃ©Ã©e:", data);
    res.json({ success: true, notification: data });
  } catch (e) {
    console.error("âŒ Erreur crÃ©ation notif:", e.message);
    res.status(500).json({ error: "Erreur crÃ©ation notification", details: e.message });
  }
});

// ğŸ“‹ RÃ©cupÃ©rer ses notifications
router.get('/', authenticateToken, async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('notifications')
      .select('*')
      .eq('created_by', req.user.id)
      .order('created_at', { ascending: false });

    if (error) throw error;
    res.json({ success: true, notifications: data });
  } catch (e) {
    console.error("âŒ Erreur lecture notifs:", e.message);
    res.status(500).json({ error: "Erreur lecture notifications", details: e.message });
  }
});

// âœ… Marquer une notification comme lue
router.patch('/:id/lue', authenticateToken, async (req, res) => {
  const notifId = req.params.id;

  try {
    const { data, error } = await supabase
      .from('notifications')
      .update({ lue: true })
      .eq('id', notifId)
      .eq('created_by', req.user.id)
      .select()
      .maybeSingle();

    if (error) throw error;
    res.json({ success: true, notification: data });
  } catch (e) {
    console.error("âŒ Erreur maj lue:", e.message);
    res.status(500).json({ error: "Erreur maj notification", details: e.message });
  }
});

// ğŸ—‘ï¸ Supprimer une notification
router.delete('/:id', authenticateToken, async (req, res) => {
  const notifId = req.params.id;

  try {
    const { error } = await supabase
      .from('notifications')
      .delete()
      .eq('id', notifId)
      .eq('created_by', req.user.id);

    if (error) throw error;
    res.json({ success: true, message: "Notification supprimÃ©e" });
  } catch (e) {
    console.error("âŒ Erreur suppression notif:", e.message);
    res.status(500).json({ error: "Erreur suppression notification", details: e.message });
  }
});

module.exports = router;


====== backend/routes/stripeWebhook.js (NOT FOUND) ======



====== backend/utils/email.js ======

// utils/email.js
const nodemailer = require('nodemailer');

// Configuration du transporteur Gmail
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS
  }
});

// Fonction pour envoyer un email HTML
async function sendEmail(to, subject, html) {
  try {
    await transporter.sendMail({
      from: process.env.EMAIL_USER, // âœ… corrigÃ© ici
      to,
      subject,
      html
    });
    console.log(`ğŸ“§ Email envoyÃ© Ã  ${to}`);
  } catch (error) {
    console.error(`âŒ Erreur envoi email Ã  ${to} :`, error.message);
  }
}

module.exports = { sendEmail };
