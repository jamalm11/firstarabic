
// ========= IMPORTS =========

const express = require('express');
const cors = require('cors');
require('dotenv').config();
const { createClient } = require('@supabase/supabase-js');
const Joi = require('joi');

const abonnementController = require('./controllers/abonnementController');
const paiementController = require('./controllers/paiementController');
const reservationsController = require('./controllers/reservationsController');
const notificationsController = require('./controllers/notificationsController');
const disponibilitesController = require('./controllers/disponibilitesController');
const { eleveSchema } = require('./validators/eleveValidator');
const { coursSchema } = require('./validators/coursValidator');
const { profSchema } = require('./validators/profValidator');
const { sendEmail } = require('./utils/email');
const ensureProfile = require('./middleware/ensureProfile');
const supabaseAdmin = require("./supabaseAdminClient");
const rateLimit = require("express-rate-limit");
// ========= APP SETUP =========

const app = express();
const PORT = 3001;

app.use(cors());
app.use(express.json());

// ========= SUPABASE CLIENT =========

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;

const supabase = createClient(supabaseUrl, supabaseKey, {
  auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false }
});


// ========= MIDDLEWARES =========
const authenticateToken = async (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ error: "Token manquant" });

  try {
    req.supabase = createClient(supabaseUrl, supabaseKey, {
      global: { headers: { Authorization: `Bearer ${token}` } },
      auth: { persistSession: false }
    });

    const { data: { user }, error } = await req.supabase.auth.getUser(token);
    if (error || !user) return res.status(401).json({ error: "Token invalide" });

    req.user = user;
    next();
  } catch (err) {
    return res.status(500).json({ error: "Erreur d'authentification" });
  }
};

app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
  next();
});
   


// ========== ROUTES ===================================

app.get('/', (req, res) => {
  res.json({ status: "API FirstArabic operationnelle !" });
});

// === ELEVE ===
app.post('/eleve', authenticateToken, async (req, res) => {
  try {
    
//    const { nom } = req.body;
//    if (!nom) return res.status(400).json({ error: "Nom requis" });
    
    const { error: validationError } = eleveSchema.validate(req.body);
    if (validationError) {
     return res.status(400).json({ error: "Donn√©es invalides", details: validationError.details[0].message });
    }
    const { nom } = req.body;
   
    const { data, error } = await req.supabase.from('eleves').insert([{ nom, created_by: req.user.id }]).select();
    if (error) throw error;
    res.json({ success: true, eleve: data[0] });
  } catch (e) {
    res.status(500).json({ error: "Erreur creation eleve", details: e.message });
  }
});

app.get('/eleves', authenticateToken, async (req, res) => {
  try {
    const { data, error } = await req.supabase.from('eleves').select('*').eq('created_by', req.user.id);
    if (error) throw error;
    res.json({ success: true, eleves: data });
  } catch (e) {
    res.status(500).json({ error: "Erreur recuperation eleves", details: e.message });
  }
});

//  NOUVELLES ROUTES ELEVE
app.get('/eleve/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { data, error } = await req.supabase
      .from('eleves')
      .select('*')
      .eq('id', id)
      .eq('created_by', req.user.id)
      .maybeSingle();
    if (error) throw error;
    res.json({ success: true, eleve: data });
  } catch (e) {
    res.status(404).json({ error: "eleve non trouve", details: e.message });
  }
});

app.put('/eleve/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { nom } = req.body;
    if (!nom) return res.status(400).json({ error: "Nom requis" });
    const { data, error } = await req.supabase
      .from('eleves')
      .update({ nom })
      .eq('id', id)
      .eq('created_by', req.user.id)
      .select();
    if (error) throw error;
    res.json({ success: true, eleve: data[0] });
  } catch (e) {
    res.status(500).json({ error: "Erreur mise a jour eleve", details: e.message });
  }
});

app.delete('/eleve/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { error } = await req.supabase
      .from('eleves')
      .delete()
      .eq('id', id)
      .eq('created_by', req.user.id);
    if (error) throw error;
    res.json({ success: true, message: "eleve supprime" });
  } catch (e) {
    res.status(500).json({ error: "Erreur suppression eleve", details: e.message });
  }
});

// R√©cup√©rer les cours d‚Äôun √©l√®ve pour une date sp√©cifique
app.get('/cours/eleve/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { date } = req.query;
    if (!date) return res.status(400).json({ error: "Date requise au format YYYY-MM-DD" });

    const { data, error } = await req.supabase
      .from('cours')
      .select(`
        id, date, statut,
        profs (nom),
        eleves (nom)
      `)
      .eq('eleve_id', id)
      .gte('date', `${date}T00:00:00`)
      .lt('date', `${date}T23:59:59`)
      .order('date', { ascending: true });

    if (error) throw error;

    res.json({ success: true, cours: data });
  } catch (e) {
    res.status(500).json({ error: "Erreur r√©cup√©ration cours √©l√®ve", details: e.message });
  }
});


// === PROF ===
// üîí Route admin : r√©cup√©rer tous les profs, valid√©s ou non
app.get('/profs/all', authenticateToken, async (req, res) => {
  try {
    const { data, error } = await req.supabase.from('profs').select('*');
    if (error) throw error;
    res.json({ success: true, profs: data });
  } catch (e) {
    res.status(500).json({ error: "Erreur recuperation profs admin", details: e.message });
  }
});

// ‚úÖ Route admin : valider un prof
app.put('/prof/:id/valider', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { error } = await req.supabase
      .from('profs')
      .update({ is_validated: true })
      .eq('id', id);
    if (error) throw error;
    res.json({ success: true, message: "Professeur valid√©" });
  } catch (e) {
    res.status(500).json({ error: "Erreur validation prof", details: e.message });
  }
});


app.post('/prof', authenticateToken, async (req, res) => {
  try {
    const { error: validationError } = profSchema.validate(req.body);
    if (validationError) return res.status(400).json({ error: validationError.details[0].message });

    const { nom, specialite, bio } = req.body;
    const { data: existing, error: selectError } = await req.supabase.from('profs').select('id').eq('created_by', req.user.id).maybeSingle();
    if (selectError) throw selectError;

    let result;
    if (existing) {
      const { data, error } = await req.supabase.from('profs').update({ nom, specialite, bio }).eq('id', existing.id).select();
      if (error) throw error;
      result = data[0];
    } else {
      const { data, error } = await req.supabase.from('profs').insert([{ nom, specialite, bio, created_by: req.user.id, is_validated: false }]).select();
      if (error) throw error;
      result = data[0];
    }
    res.json({ success: true, prof: result });
  } catch (e) {
    res.status(500).json({ error: "Erreur enregistrement prof", details: e.message });
  }
});

app.get('/profs', async (req, res) => {
  try {
    const { data, error } = await supabase.from('profs').select('id, nom, specialite, bio').eq('is_validated', true);
    if (error) throw error;
    res.json({ success: true, profs: data });
  } catch (e) {
    res.status(500).json({ error: "Erreur recuperation profs", details: e.message });
  }
});

app.get('/prof/me', authenticateToken, async (req, res) => {
  try {
    const { data, error } = await req.supabase.from('profs').select('*').eq('created_by', req.user.id).maybeSingle();
    if (error) throw error;
    res.json({ success: true, prof: data });
  } catch (e) {
    res.status(500).json({ error: "Erreur recuperation profil prof", details: e.message });
  }
});

// === COURS ===

app.post('/cours', authenticateToken, async (req, res) => {
  try {
    const { error: validationError } = coursSchema.validate(req.body);
    if (validationError) return res.status(400).json({ error: validationError.details[0].message });

    const { date, prof_id, eleve_id } = req.body;
    // G√©n√©ration du lien Jitsi unique
    const slug = `${prof_id}-${eleve_id}-${Date.now()}`;
    const jitsi_url = `https://meet.jit.si/FirstArabic-${slug}`;

    const { data, error } = await req.supabase.from('cours').insert([{
      date,
      prof_id,
      eleve_id,
      statut: 'confirme',
      jitsi_url,
      created_by: req.user.id
    }]).select('*');

    if (error) throw error;

    // ‚úÖ R√©cup√©rer les emails
    const { data: profData } = await req.supabase.from('profs').select('email').eq('id', prof_id).maybeSingle();
    const { data: eleveData } = await req.supabase.from('eleves').select('email').eq('id', eleve_id).maybeSingle();

    const emailBody = `
      <p>Un nouveau cours a √©t√© programm√©.</p>
      <p>Date : ${date}</p>
      <p>Lien Jitsi : <a href="${jitsi_url}">${jitsi_url}</a></p>
    `;

    if (profData?.email) await sendEmail(profData.email, "Nouveau cours", emailBody);
    if (eleveData?.email) await sendEmail(eleveData.email, "Nouveau cours", emailBody);

    res.json({ success: true, cours: data[0] });
  } catch (e) {
    res.status(500).json({ error: "Erreur creation cours", details: e.message });
  }
});


app.get('/cours', authenticateToken, async (req, res) => {
  try {
    const { data, error } = await req.supabase
      .from('cours')
      .select(`
        id, date, statut,
        profs (nom),
        eleves (nom)
      `);

    if (error) throw error;

    const coursAvecNoms = data.map(c => ({
      id: c.id,
      date: c.date,
      statut: c.statut,
      prof_nom: c.profs?.nom || null,
      eleve_nom: c.eleves?.nom || null
    }));

    res.json({ success: true, cours: coursAvecNoms });
  } catch (e) {
    res.status(500).json({ error: "Erreur rcupration cours enrichis", details: e.message });
  }
});

// app.get('/cours', authenticateToken, async (req, res) => {
//  try {
//    const { data, error } = await req.supabase.from('cours').select('*');
//    if (error) throw error;
//    res.json({ success: true, cours: data });
//  } catch (e) {
//    res.status(500).json({ error: "Erreur recuperation cours", details: e.message });
//  }
//});

app.get('/cours/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { data, error } = await req.supabase
      .from('cours')
      .select(`
        id, date, statut, jitsi_url,
        profs (nom),
        eleves (nom)
      `)
      .eq('id', id)
      .maybeSingle();

    if (error) throw error;
    if (!data) return res.status(404).json({ error: "Cours introuvable" });

    res.json({
      success: true,
      cours: {
        id: data.id,
        date: data.date,
        statut: data.statut,
        jitsi_url: data.jitsi_url,
        prof_nom: data.profs?.nom || null,
        eleve_nom: data.eleves?.nom || null
      }
    });
  } catch (e) {
    res.status(500).json({ error: "Erreur r√©cup√©ration cours", details: e.message });
  }
});


//app.get('/cours/:id', authenticateToken, async (req, res) => {
//  try {
//    const { id } = req.params;
//    const { data, error } = await req.supabase.from('cours').select('*').eq('id', id).maybeSingle();
//    if (error) throw error;
//    res.json({ success: true, cours: data });
//  } catch (e) {
//    res.status(404).json({ error: "Cours non trouve", details: e.message });
//  }
//});

app.put('/cours/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { statut } = req.body;
    const { data, error } = await req.supabase.from('cours').update({ statut }).eq('id', id).select();
    if (error) throw error;
    res.json({ success: true, cours: data[0] });
  } catch (e) {
    res.status(500).json({ error: "Erreur mise a jour cours", details: e.message });
  }
});

app.delete('/cours/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { error } = await req.supabase.from('cours').delete().eq('id', id);
    if (error) throw error;
    res.json({ success: true, message: "Cours supprime" });
  } catch (e) {
    res.status(500).json({ error: "Erreur suppression cours", details: e.message });
  }
});

 
// === PLANNING GLOBAL ===
app.get('/planning', authenticateToken, async (req, res) => {
  try {
    const statut = req.query.statut || null;

    const { data, error } = await req.supabase
      .from('cours')
      .select(`
        id, date, statut, jitsi_url,
        profs (nom),
        eleves (nom)
      `)
      .eq('created_by', req.user.id);

    if (error) throw error;

    const planning = data
      .filter(c => !statut || c.statut === statut)
      .map(c => ({
        id: c.id,
        date: c.date,
        statut: c.statut,
        lien: c.jitsi_url,
        prof: c.profs?.nom || null,
        eleve: c.eleves?.nom || null
      }));

    res.json({ success: true, planning });
  } catch (e) {
    res.status(500).json({ error: "Erreur r√©cup√©ration planning", details: e.message });
  }
});

// backend/index.js (ajouter vers la fin du fichier)

// üîê Middleware d'authentification d√©j√† pr√©sent
//const authenticateToken = require('./middleware/authenticateToken');

// üìÖ Route: r√©cup√©rer tous les cr√©neaux R√âSERV√âS (cours confirm√©s)
app.get('/creneaux/reserves', authenticateToken, async (req, res) => {
  try {
    const { prof_id } = req.query;
    if (!prof_id) return res.status(400).json({ error: 'prof_id requis' });

    const { data, error } = await req.supabase
      .from('cours')
      .select('date')
      .eq('prof_id', prof_id)
      .eq('statut', 'confirme');

    if (error) throw error;

    const dureeCoursMin = 30;
    const reserves = data.map(c => {
      const start = new Date(c.date);
      const end = new Date(start.getTime() + dureeCoursMin * 60000);
      return { start: start.toISOString(), end: end.toISOString() };
    });

    res.json({ success: true, reserves });
  } catch (e) {
    res.status(500).json({ error: 'Erreur r√©cup√©ration cr√©neaux r√©serv√©s', details: e.message });
  }
});

// üìÜ Route: r√©cup√©rer tous les cr√©neaux DISPONIBLES (via disponibilites)

app.get('/creneaux/disponibles', authenticateToken, async (req, res) => {
  try {
    const { prof_id } = req.query;
    if (!prof_id) return res.status(400).json({ error: 'prof_id requis' });

    // üîπ √âtape 1: r√©cup√©rer les disponibilit√©s hebdo du prof
    const { data: disponibilites, error: dispoError } = await req.supabase
      .from('disponibilites')
      .select('jour, heure_debut, heure_fin')
      .eq('prof_id', prof_id);

    if (dispoError) throw dispoError;

    // üîπ √âtape 2: g√©n√©rer les cr√©neaux pour la prochaine semaine
    const joursMap = {
      lundi: 1, mardi: 2, mercredi: 3, jeudi: 4, vendredi: 5, samedi: 6, dimanche: 0
    };

    const dureeCoursMin = 30;
    const now = new Date();
    const prochainsCreneaux = [];

    for (const dispo of disponibilites) {
      const dayOffset = (7 + joursMap[dispo.jour.toLowerCase()] - now.getDay()) % 7;
      const dateCreneau = new Date(now);
      dateCreneau.setDate(now.getDate() + dayOffset);
      dateCreneau.setHours(0, 0, 0, 0);

      const [hStart, mStart] = dispo.heure_debut.split(':').map(Number);
      const [hEnd, mEnd] = dispo.heure_fin.split(':').map(Number);

      const start = new Date(dateCreneau);
      start.setHours(hStart, mStart, 0);

      const end = new Date(dateCreneau);
      end.setHours(hEnd, mEnd, 0);

      for (let t = new Date(start); t < end; t.setMinutes(t.getMinutes() + dureeCoursMin)) {
        const creneauStart = new Date(t);
        const creneauEnd = new Date(t.getTime() + dureeCoursMin * 60000);
        prochainsCreneaux.push({ start: creneauStart.toISOString(), end: creneauEnd.toISOString() });
      }
    }

    // üîπ √âtape 3: r√©cup√©rer les cr√©neaux r√©serv√©s
    const { data: reserves, error: reserveError } = await req.supabase
      .from('cours')
      .select('date')
      .eq('prof_id', prof_id)
      .eq('statut', 'confirme');

    if (reserveError) throw reserveError;

    const reservesSet = new Set(reserves.map(r => new Date(r.date).toISOString()));

    // üîπ √âtape 4: filtrer les creneaux d√©j√† r√©serv√©s
    const disponibles = prochainsCreneaux.filter(c => !reservesSet.has(c.start));

    res.json({ success: true, disponibles });
  } catch (e) {
    res.status(500).json({ error: 'Erreur r√©cup√©ration disponibilit√©s filtr√©es', details: e.message });
  }
});


// verifier  les emails lors de l'enregistrement pour detecter les emails deja utilise


const emailCheckLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // max 5 requ√™tes
  message: "Trop de tentatives. R√©essayez plus tard.",
});

app.post("/check-email", emailCheckLimiter, async (req, res) => {
  const { email } = req.body;

  if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    return res.status(400).json({ error: "Format d'email invalide" });
  }

  try {
    const { data, error } = await supabaseAdmin.auth.admin.listUsers();

    if (error) {
      console.error("‚ùå Supabase error:", error);
      return res.status(500).json({ error: "Erreur Supabase" });
    }

    const exists = data.users.some((u) => u.email === email);
    console.log(`üîç V√©rif email : ${email} ‚Üí ${exists ? "EXISTE" : "DISPO"}`);

    return res.json({ exists });
  } catch (err) {
    console.error("‚ùå Exception:", err);
    return res.status(503).json({ error: "Service indisponible" });
  }
});








// notifications

app.post("/notifications", authenticateToken, notificationsController.createNotification);
app.get("/notifications", authenticateToken, notificationsController.getNotifications);
app.put("/notifications/:id", authenticateToken, notificationsController.markAsRead);
app.delete("/notifications/:id", authenticateToken, notificationsController.deleteNotification);

// disponibilite

app.post("/disponibilites", authenticateToken, disponibilitesController.createDisponibilite);
app.get("/disponibilites", authenticateToken, disponibilitesController.getDisponibilites);

app.get("/disponibilites/:id", authenticateToken, disponibilitesController.getDisponibiliteById);
app.put("/disponibilites/:id", authenticateToken, disponibilitesController.updateDisponibilite);
app.delete("/disponibilites/:id", authenticateToken, disponibilitesController.deleteDisponibilite);
app.patch("/disponibilites/:id", authenticateToken, disponibilitesController.updateDisponibilite);

// reservations
app.post("/reservations", authenticateToken, reservationsController.createReservation);
app.get("/reservations", authenticateToken, reservationsController.getReservations);
app.get("/reservations/:id", authenticateToken, reservationsController.getReservationById);
app.delete("/reservations/:id", authenticateToken, reservationsController.deleteReservation);
app.put("/reservations/:id", authenticateToken, reservationsController.updateReservation);

//  index.js

app.post("/stripe/webhook", express.raw({ type: 'application/json' }), paiementController.handleStripeWebhook);
// abonnements
app.get('/abonnements', authenticateToken, abonnementController.getAbonnementsForUser);
app.get('/abonnements/all', authenticateToken, abonnementController.getAllAbonnements); // üîí Pour admin ou consultation
app.post('/abonnements/checkout', authenticateToken, abonnementController.createCheckoutSession); // üöÄ D√©marre un paiement Stripe




app.listen(PORT, () => {
  console.log(`API en ecoute sur http://localhost:${PORT}`);
});
const pool = require('../db');
const { coursSchema } = require('../validators/coursValidator');

// üî∏ Cr√©er un cours
const createCours = async (req, res) => {
  const { error: validationError } = coursSchema.validate(req.body);
  if (validationError) return res.status(400).json({ error: validationError.details[0].message });

  const { date, prof_id, eleve_id, statut } = req.body;
  const created_by = req.user.id;

  try {
    const result = await pool.query(
      `INSERT INTO cours (date, prof_id, eleve_id, statut, created_by)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING *`,
      [date, prof_id, eleve_id, statut, created_by]
    );
    res.json({ success: true, cours: result.rows[0] });
  } catch (err) {
    console.error('Erreur cr√©ation cours:', err);
    res.status(500).json({ error: "Erreur serveur lors de la cr√©ation du cours" });
  }
};

// üî∏ R√©cup√©rer tous les cours
const getAllCours = async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT c.*, e.nom AS eleve_nom, p.nom AS prof_nom
      FROM cours c
      JOIN eleves e ON c.eleve_id = e.id
      JOIN profs p ON c.prof_id = p.id
      ORDER BY c.date DESC
    `);
    res.json({ success: true, cours: result.rows });
  } catch (err) {
    console.error('Erreur r√©cup√©ration cours:', err);
    res.status(500).json({ error: "Erreur serveur lors de la r√©cup√©ration des cours" });
  }
};

// üî∏ R√©cup√©rer un cours par ID
const getCoursById = async (req, res) => {
  const id = req.params.id;
  try {
    const result = await pool.query(
      `SELECT * FROM cours WHERE id = $1`,
      [id]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Cours introuvable" });
    }
    res.json({ success: true, cours: result.rows[0] });
  } catch (err) {
    console.error('Erreur r√©cup√©ration cours:', err);
    res.status(500).json({ error: "Erreur serveur" });
  }
};

// üî∏ Mettre √† jour un cours
const updateCours = async (req, res) => {
  const id = req.params.id;
  const { date, statut } = req.body;

  try {
    const result = await pool.query(
      `UPDATE cours
       SET date = COALESCE($1, date),
           statut = COALESCE($2, statut)
       WHERE id = $3
       RETURNING *`,
      [date, statut, id]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Cours non trouv√©" });
    }
    res.json({ success: true, cours: result.rows[0] });
  } catch (err) {
    console.error('Erreur mise √† jour cours:', err);
    res.status(500).json({ error: "Erreur serveur lors de la mise √† jour" });
  }
};

// üî∏ Supprimer un cours
const deleteCours = async (req, res) => {
  const id = req.params.id;
  try {
    const result = await pool.query(
      `DELETE FROM cours WHERE id = $1 RETURNING *`,
      [id]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Cours introuvable" });
    }
    res.json({ success: true, message: "Cours supprim√©" });
  } catch (err) {
    console.error('Erreur suppression cours:', err);
    res.status(500).json({ error: "Erreur serveur lors de la suppression" });
  }
};

module.exports = {
  createCours,
  getAllCours,
  getCoursById,
  updateCours,
  deleteCours
};
// src/App.js
import Professeurs from "./pages/Professeurs";
import Reservation from "./pages/Reservation";
import Planning from "./pages/Planning";
import ResetPassword from "./pages/ResetPassword";
import ForgotPassword from './pages/ForgotPassword';
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import Login from "./components/Login";
import Register from "./pages/Register";
import Dashboard from "./pages/Dashboard";
import ProfDashboard from "./pages/ProfDashboard";

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<Login />} />
        <Route path="/register" element={<Register />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/prof-dashboard" element={<ProfDashboard />} />
        <Route path="/forgot-password" element={<ForgotPassword />} />
        <Route path="/planning" element={<Planning />} />
        <Route path="/reservation" element={<Reservation />} />
        <Route path="/professeurs" element={<Professeurs />} />
        <Route path="/reset-password" element={<ResetPassword />} />
        {/* ‚úÖ Pas besoin de /login, la page de connexion est d√©j√† sur / */}
      </Routes>
    </Router>
  );
}

export default App;
// src/App.js
import Professeurs from "./pages/Professeurs";
import Reservation from "./pages/Reservation";
import Planning from "./pages/Planning";
import ResetPassword from "./pages/ResetPassword";
import ForgotPassword from './pages/ForgotPassword';
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import Login from "./components/Login";
import Register from "./pages/Register";
import Dashboard from "./pages/Dashboard";
import ProfDashboard from "./pages/ProfDashboard";

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<Login />} />
        <Route path="/register" element={<Register />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/prof-dashboard" element={<ProfDashboard />} />
        <Route path="/forgot-password" element={<ForgotPassword />} />
        <Route path="/planning" element={<Planning />} />
        <Route path="/reservation" element={<Reservation />} />
        <Route path="/professeurs" element={<Professeurs />} />
        <Route path="/reset-password" element={<ResetPassword />} />
        {/* ‚úÖ Pas besoin de /login, la page de connexion est d√©j√† sur / */}
      </Routes>
    </Router>
  );
}

export default App;
// src/pages/Reservation.js
import React, { useEffect, useState } from "react";
import { useLocation, useNavigate, Link } from "react-router-dom";
import DatePicker from "react-datepicker";
import "react-datepicker/dist/react-datepicker.css";
import { supabase } from "../supabaseClient";
import axios from "axios";

function Reservation() {
  const [session, setSession] = useState(null);
  const [token, setToken] = useState(null);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [selectedTime, setSelectedTime] = useState("09:00");
  const [prof, setProf] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const navigate = useNavigate();
  const location = useLocation();
  const profId = new URLSearchParams(location.search).get("prof_id");

  // 1. R√©cup√©ration session Supabase
  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setToken(session?.access_token || null);
    });
  }, []);

  // 2. R√©cup√©ration du professeur
  useEffect(() => {
    const fetchProf = async () => {
      if (!token || !profId) {
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);

      try {
        const res = await axios.get("http://localhost:3001/profs", {
          headers: { Authorization: `Bearer ${token}` },
        });

        const found = res.data?.profs?.find((p) => p.id === profId);
        if (!found) {
          setError("Professeur introuvable");
          return;
        }

        setProf(found);
      } catch (err) {
        console.error("‚ùå Erreur r√©cup√©ration prof :", err);
        setError("Erreur lors du chargement du professeur");
      } finally {
        setLoading(false);
      }
    };

    fetchProf();
  }, [token, profId]);

  // 3. Envoi de la r√©servation
  const handleReservation = async () => {
    try {
      const fullDate = new Date(selectedDate);
      const [hours, minutes] = selectedTime.split(":").map(Number);
      fullDate.setHours(hours, minutes, 0);

      const { data: eleveData } = await axios.get("http://localhost:3001/eleves", {
        headers: { Authorization: `Bearer ${token}` },
      });

      const eleve_id = eleveData.eleves[0]?.id;
      if (!eleve_id) throw new Error("√âl√®ve non trouv√©");

      await axios.post(
        "http://localhost:3001/cours",
        {
          date: fullDate.toISOString(),
          prof_id: profId,
          eleve_id,
        },
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );

      alert("‚úÖ Cours r√©serv√© avec succ√®s !");
      navigate("/dashboard");
    } catch (err) {
      console.error("‚ùå Erreur r√©servation :", err);
      alert("Erreur lors de la r√©servation");
    }
  };

  // 4. Affichage conditionnel (les hooks sont d√©j√† appel√©s donc c'est OK ici)
  if (!profId) {
    return (
      <div style={{ padding: "2rem" }}>
        <p>‚ö†Ô∏è Aucun professeur s√©lectionn√©.</p>
        <p>
          Veuillez d‚Äôabord <Link to="/professeurs">choisir un professeur</Link>.
        </p>
      </div>
    );
  }

  if (!session) return <p>üîê Veuillez vous connecter</p>;
  if (error) return <p>‚ùå {error}</p>;
  if (loading) return <p>‚è≥ Chargement du professeur...</p>;
  if (!prof) return <p>‚ö†Ô∏è Professeur non trouv√©</p>;

  return (
    <div style={{ padding: "2rem" }}>
      <h2>üìÖ R√©server un cours avec {prof.nom}</h2>

      <label>Date :</label>
      <DatePicker selected={selectedDate} onChange={setSelectedDate} />

      <br />
      <label>Heure :</label>
      <select value={selectedTime} onChange={(e) => setSelectedTime(e.target.value)}>
        {["08:00", "09:00", "10:00", "11:00", "14:00", "15:00", "16:00", "17:00"].map((h) => (
          <option key={h} value={h}>{h}</option>
        ))}
      </select>

      <br />
      <button onClick={handleReservation} style={{ marginTop: "1rem" }}>
        R√©server ce cr√©neau
      </button>
    </div>
  );
}

export default Reservation;
// src/App.js
import Professeurs from "./pages/Professeurs";
import Reservation from "./pages/Reservation";
import Planning from "./pages/Planning";
import ResetPassword from "./pages/ResetPassword";
import ForgotPassword from './pages/ForgotPassword';
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import Login from "./components/Login";
import Register from "./pages/Register";
import Dashboard from "./pages/Dashboard";
import ProfDashboard from "./pages/ProfDashboard";

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<Login />} />
        <Route path="/register" element={<Register />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/prof-dashboard" element={<ProfDashboard />} />
        <Route path="/forgot-password" element={<ForgotPassword />} />
        <Route path="/planning" element={<Planning />} />
        <Route path="/reservation" element={<Reservation />} />
        <Route path="/professeurs" element={<Professeurs />} />
        <Route path="/reset-password" element={<ResetPassword />} />
        {/* ‚úÖ Pas besoin de /login, la page de connexion est d√©j√† sur / */}
      </Routes>
    </Router>
  );
}

export default App;
